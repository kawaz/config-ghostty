---
description: ターミナルアクションのキーバインディングを設定
platform: all
default:
---

# keybind

**Language:** [English](../../en/config/keybind.en.md) | 日本語

## Description

キーバインディング。形式は `trigger=action` です。重複するトリガーは以前に設定された値を上書きします。アクションのリストはドキュメントまたは `ghostty +list-actions` コマンドを使用して利用できます。

### トリガー

`+` で区切られたキーとモディファイアのリスト。例: `ctrl+a`、`ctrl+shift+b`、`up`。

キーが単一の Unicode コードポイント場合、トリガーはそのコードポイントを生成するすべてのプレスと一致します。これらはキーボード レイアウトの影響を受けます。たとえば、`a` は QWERTY キーボードの `a` キーと一致しますが、AZERTY キーボードの `q` キーと一致します (米国の物理的なレイアウトを想定)。

Unicode コードポイントの場合、マッチングは修飾子セットと修飾されていないコードポイントを比較することで行われます。修飾されていないコードポイントは他のソフトウェアでは「修飾されていない文字」と呼ばれることもありますが、シフトだけでなくすべての修飾子が考慮されます。たとえば、`ctrl+a` は `a` と一致しますが、`ctrl+shift+a` (米国キーボードでは `A`) には一致しません。

さらに、コードポイント マッチングは大文字と小文字を区別しず、修飾されていないコードポイントは常に比較用に大文字と小文字が折りられます。その結果、設定された `ctrl+A` は `ctrl+a` が押されたときにマッチします。このことは、キーボード レイアウトに応じて一部のキーの組み合わせが不可能であることを意味することに注意してください。たとえば、`ctrl+_` は米国キーボードでは不可能です。これは、`_` が `shift+-` であり、`ctrl+shift+-` が `ctrl+_` と等しくないためです (モディファイアが一致していないため)。不可能なキー組み合わせの詳細については、Qt 開発者によって書かれた優れたソースを参照してください: https://doc.qt.io/qt-6/qkeysequence.html#keyboard-layout-issues

物理キー コードは W3C 仕様で指定されたキー コードのいずれかを使用して指定できます。たとえば、`KeyA` は米国標準キーボード上の物理的な `a` キーと一致します。キーボード レイアウトに関係なく。これらは大文字と小文字を区別します。

美しさのために、w3c コードはスネークケースもサポートしています。たとえば、`key_a` は `KeyA` と同等です。唯一の例外は機能キーです。たとえば、`F1` は `f1` です (アンダースコアなし)。これは内部コードがスネークケースを使用するための結果ですが、意図的にサポートおよびテストされているため、使用しても安全です。より美しいすべて小文字のバインディングを許可します。

`insert`、`up`、`f5` などの機能キーも、前述の W3C 仕様で指定されたキーを使用して指定されます。

物理キーは常に Unicode コードポイントより高い優先度でマッチするため、`a` と `KeyA` の両方を指定した場合、物理キーは設定順序に関係なく常に使用されます。

有効なモディファイアは `shift`、`ctrl` (別名: `control`)、`alt` (別名: `opt`、`option`)、および `super` (別名: `cmd`、`command`) です。モディファイアまたは別名を使用できます。キーバインディングをデバッグするときは、エイリアスなしのモディファイアが常に出力で使用されます。

注: キーボードの fn または「グローブ」キーはモディファイアとしてサポートされていません。これは、Ghostty が使用するオペレーティング システムと GUI ツールキットの制限です。

トリガーに関するいくつかの追加メモ:

- モディファイアは繰り返すことはできません。`ctrl+ctrl+a` は無効です。
- モディファイアとキーはどの順序でもかまいません。`shift+a+ctrl` は *奇妙* ですが、有効です。
- 単一のキー入力のみが許可されます。`ctrl+a+b` は無効です。

`>` で区切られた複数のトリガーを指定して、アクションをアクティブにするためのトリガーのシーケンスを要求することもできます。たとえば、`ctrl+a>n=new_window` は、ユーザーが `ctrl+a` の後に `n` を別途押した場合にのみ `new_window` アクションをトリガーします。他のソフトウェアでは、これはリーダー キー、キー コード、キー テーブルなどと呼ばれることもあります。シーケンスの部分の数には、ハードコードされた制限はありません。

警告: シーケンスを `ghostty` への CLI 引数として定義する場合は、ほとんどのシェルで `>` が特殊文字であるため、キーバインディングを引用する必要があります。例: ghostty --keybind='ctrl+a>n=new_window'

トリガー シーケンスには特別な処理があります:

- Ghostty はシーケンス内の次のキーを無期限に待機します。タイムアウトを指定する方法はありません。プレフィックス キーの出力を強制する唯一の方法は、そのキーを具体的に出力するための別のキーバインディングを割り当てることです(例: `ctrl+a>ctrl+a=text:foo`)、またはバインドされていないキーを押して両方のキーをプログラムに送信することです。
- シーケンス内のプレフィックスが以前にバインドされている場合、シーケンスは前のバインディングをオーバーライドします。たとえば、`ctrl+a` が `new_window` にバインドされ、`ctrl+a>n` が `new_tab` にバインドされている場合、`ctrl+a` を押すと何もしません。
- 上記に加えて、以前にバインドされたシーケンス プレフィックスが新しい非シーケンス バインディングで使用される場合、以前にバインドされたシーケンス全体がバインド解除されます。たとえば、`ctrl+a>n` と `ctrl+a>t` をバインドしてから `ctrl+a` を直接バインドすると、`ctrl+a>n` と `ctrl+a>t` の両方がバインド解除されます。
- `global:` または `all:` がプレフィックスされたトリガーではトリガー シーケンスは許可されません。これは今後削除できる制限です。

### アクション

トリガーが満たされときに実行するアクションです。形式は `action` または `action:param` です。後者の形式は、アクションがパラメーターを必要とする場合にのみ有効です。

- `ignore` - 何もしない、キー入力を無視します。これは特定の入力をブラック ホール化して効果がないようにするために使用できます。
- `unbind` - バインディングを削除します。これにより、前のアクションが削除されます。キーが印字可能な場合は、子コマンドに送信されます。アンバインドは、`physical:` プレフィックス付きトリガーを含め、マッチするすべてのトリガーを削除します。プレフィックスを指定する必要はありません。
- `csi:text` - CSI シーケンスを送信します。たとえば、`csi:A` は「カーソル上」を送信します。
- `esc:text` - エスケープ シーケンスを送信します。たとえば、`esc:d` は右側の単語の終わりまで削除します。
- `text:text` - 文字列を送信します。Zig 文字列リテラル構文を使用します。たとえば、`text:\x15` は Ctrl-U を送信します。
- その他のすべてのアクションはドキュメントまたは `ghostty +list-actions` コマンドを使用して見つけることができます。

アクションに関するいくつかのメモ:

- パラメーターは `:` の後に「そのまま」取得されます。二重引用符またはその他のメカニズムは含まれており、解析されません。スペースを含む文字列値を送信したい場合は、トリガー/アクション全体を二重引用符で囲みます。例: `--keybind="up=csi:A B"`

キーバインディング用に指定できる特別な値があります:

- `keybind=clear` はすべての設定済みキーバインディングをクリアします。警告: これにより、デフォルトのキーバインディングを含め、この時点までのすべてのキーバインディングが削除されます。

### 特別なプレフィックス

キーバインディング トリガーは、キーバインディングの動作を変更するために特別な値でプレフィックスされます。これらは:

#### `all:`

キーバインディングをすべてのターミナル サーフェスに適用します。デフォルトでは、キーバインディングはフォーカスされたターミナル サーフェスにのみ適用されます。これが true の場合、キーバインディングはすべてのターミナル サーフェスに送信されます。これは、サーフェス固有のアクションにのみ適用されます。すでにグローバルなアクション (たとえば `quit`) の場合、このプレフィックスは効果がありません。

利用可能: 1.0.0 以降

#### `global:`

キーバインディングをグローバルにします。デフォルトでは、キーバインディングは Ghostty 内でのみ機能し、適切な条件下で (アプリケーション フォーカス、時々ターミナルフォーカス等)。キーバインディングをシステム全体でグローバルに機能させたい場合 (Ghostty がフォーカスされていない場合でも)、このプレフィックスを指定します。このプレフィックスは `all:` を暗に示します。

注: これは全ての環境で機能しません。詳細については下記の追加メモを参照してください。

利用可能: macOS では 1.0.0、GTK では 1.2.0

#### `unconsumed:`

入力を使用しません。デフォルトでは、キーバインディングは入力を使用します。つまり、関連するエンコーディング (存在する場合) はターミナルで実行中のプログラムに送信されません。プログラムにエンコードされた値を送信したい場合は、キーバインディング全体の前に `unconsumed:` プレフィックスを指定します。例: `unconsumed:ctrl+a=reload_config`。`global:` と `all:` プレフィックス付きキーバインディングは、この設定に関係なく常に入力を使用します。特定のターミナル サーフェスに関連付けられていないため、エンコードされることはありません。

利用可能: 1.0.0 以降

#### `performable:`

アクションが実行可能な場合にのみ入力を使用します。たとえば、`copy_to_clipboard` アクションは、コピーする選択がある場合にのみ入力を使用します。選択がない場合、Ghostty はキーバインディングが設定されていないかのように動作します。これは `global:` または `all:` プレフィックス付きキーバインディングには効果がありません。キー シーケンスの場合、アクションが実行不可の場合、シーケンスがリセットされます (キーバインディングが設定されていない場合と同じように動作します)。

実行可能なキーバインディングはアプリケーション メニューのメニュー ショートカットとして表示されません。これは、メニュー ショートカットがターミナルの状態に関係なくアクションを実行するように強制するためです。実行可能なキーバインディングは引き続き機能しますが、メニューにショートカット ラベルとして表示されません。

利用可能: 1.1.0 以降

キーバインディング トリガーはプレフィックスの組み合わせごとに一意ではありません。たとえば、`ctrl+a` と `global:ctrl+a` は 2 つの別のキーバインディングではありません。後で設定されたキーバインディングは前に設定されたキーバインディングを上書きします。この場合、`global:` キーバインディングが使用されます。

複数のプレフィックスを指定できます。たとえば、`global:unconsumed:ctrl+a=reload_config` はキーバインディングをグローバルにし、設定をリロードするために入力を使用しません。

注: `global:` は macOS とあるれ Linux プラットフォームでのみサポートされています。

macOS では、この機能を Ghostty に付与するには、アクセシビリティ権限が必要です。`global:` キーバインディングが指定され、Ghostty が起動またはリロードされるときに、Ghostty はこれらの権限をリクエストしようとします。権限が付与されていない場合、キーバインディングは機能しません。macOS では、これらの権限は [システム環境設定 -> プライバシーとセキュリティ -> アクセシビリティ] で見つけることができます。

Linux では、デスクトップ環境が [Global Shortcuts](https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.GlobalShortcuts.html) プロトコルを XDG デスクトップ プロトコルの実装の一部として実装する必要があります。グローバル ショートカットがサポートされている (またはサポートされていない) ことがわかっているデスクトップ環境には:

- KDE Plasma ([5.27](https://kde.org/announcements/plasma/5/5.27.0/#wayland) 以降) と GNOME ([48](https://release.gnome.org/48/#and-thats-not-all) 以降) を使用しているユーザーは、ほとんど構成なしでグローバル ショートカットを使用できることが期待されます。
- Hyprland では手動設定が必要です。[Hyprland Wiki](https://wiki.hyprland.org/Configuring/Binds/#dbus-global-shortcuts) で説明されている手順を参照して、グローバル ショートカットを正しく設定してください。(重要: [`xdg-desktop-portal-hyprland`](https://wiki.hyprland.org/Hypr-Ecosystem/xdg-desktop-portal-hyprland/) もインストールする必要があります!)
- 特に、グローバル ショートカットは Sway などの wlroots ベースのコンポーザーに実装されていません ([upstream issue](https://github.com/emersion/xdg-desktop-portal-wlr/issues/240))。

## Default

```conf
# https://github.com/kawaz/config-ghostty/blob/main/docs/ja/config/keybind.ja.md
# ターミナルアクションのキーバインディングを設定 (default: ドキュメント参照)
keybind = super+shift+d=new_split:down
keybind = super+enter=toggle_fullscreen
```

デフォルトのキーバインディングの完全なリストはドキュメントを参照してください。
