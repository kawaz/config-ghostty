# これは「command」と同じですが、Ghosttyの起動時に作成される最初のターミナル
# サーフェスにのみ適用されます。その後のターミナルサーフェスは
# `command` 設定を使用します。
#
# 最初のターミナルサーフェスが作成される（または閉じられる）と、
# 以降このイニシャルコマンドを自動的に実行する方法はありません。そのため、
# これをランタイムに設定しても、次のターミナルサーフェスが
# これまでに作成されたはじめてのサーフェスである場合にのみ有効です。
#
# `ghostty` CLIを使用している場合は、引数を直接設定するショートカットもあります：
# `-e` フラグを使用できます。例：`ghostty -e
# fish --with --custom --args`。`-e` フラグは自動的に以下のような
# その他の動作も強制します：
#
#   * シェルの展開を無効化します。入力がすでに
#     アップストリーム側でシェルを展開されていることが期待されるため
#     （例：`ghostty -e` コマンドを入力するのに使用されたシェル）。
#
#   * `gtk-single-instance=false` - これにより、新しいインスタンスが
#     起動され、CLIの引数が尊重されることが保証されます。
#
#   * `quit-after-last-window-closed=true` - これにより、Ghosttyプロセスが
#     コマンド終了時に終了することが保証されます。さらに、
#     `quit-after-last-window-closed-delay` はリセットされます。
#
#   * `shell-integration=detect`（`none` でない場合）- これにより、
#     設定されたシェル統合をコマンドの環境に強制的に
#     挿入することを防ぎます。`-e` では、シェルを実行している
#     可能性は非常に低く、強制的なシェル統合は問題を引き起こす可能性が
#     高いです（例：コマンドをシェルでラップする、環境変数を設定するなど）。
#     これは予期しない動作を防ぐための安全措置です。`-e` で実行されたコマンドで
#     シェル統合を使用したい場合は、バイナリに適切な名前を付けるか、
#     シェル統合スクリプトを手動でソースすることのいずれかを行う必要があります。
initial-command =
